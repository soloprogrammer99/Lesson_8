<!DOCTYPE html>
<html lang="ru">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="stylesheet" href="css/style.css">
   <title>Lesson_8</title>
</head>

<body>
   <main class="main">
      <header class="header">
         <div class="wrapper"></div>
         <h2>Псевдоклассы</h2>
         <div class="box">
            <p>Есть несколько категорий псевдоклассов:</p>
         </div>
         <div class="box">
            <h3>Псевдоклассы состояния.</h3>
         </div>
         <div class="box">
            <p><span class="span">1. Псевдоклассы состояния.</span> По другому статус. Говорит, в каком статусе
               (состоянии) находится сейчас данный объект.</p>
         </div>
         <div class="box">
            <h4>Псевдокласс hover</h4>
            <p><span class="span_2">hover</span> При наведении мыши на объект он получает первый псевдокласс
               состояния. </p>
            <p>Например, в состоянии покоя ссылка будет выкрашена в <span style="color: green;">зелёный цвет:</span>
            </p>
            <img src="img/rest.png" class="img_rest" alt="Ссылка без hover">
         </div>
         <div class="box">
            <p>А в состоянии <span class="span">hover</span> (при наведении курсора мыши или срабатывания какого-то
               события) ссылка будет
               выкрашена в <span style="color: red;"> красный:</span></p>
            <img src="img/hover.png" class="img_hover" alt="">
         </div>
         <p>Пример:</p>
         <div class="block">
            <a href="" class="link">Я ссылка</a>
         </div>
         <p>А здесь размещена ссылка, исчезающая при наведении курсора мыши. </p>
         <div class="block_2">
            <a href="" class="link_2">Я ссылка (исчезающая при наведении курсора мыши)</a>
         </div>
         <div class="box">
            <p>А сейчас у нас объект скрыт, но мы хотим его показать. Для того, чтобы "прослушать" отобразить <span
                  class="span">hover</span>,
               нам нужно разделить сам объект, место, где мы будем "слушать" <span class="span">hover</span> и сам
               объект, который должен
               реагировать на наведение (вложенность). Мы будем слушать <span class="span">hover</span> на "родителе"
               <span class="span">block_2</span>. Мы на него
               повесили "прослушку" <span class="span">hover</span>. Нам нужно отобразить ссылку. Соответственно, мы
               обращаемся к вложенной в
               него ссылке. Поэтому синтаксис записи будет выглядеть так:
            </p>
            <img src="img/hover.link.png" class="img_hover" alt="">
         </div>
         <div class="box">
            <p>Когда нужно взаимодействовать со скрытым объектом, слушайте "родителя"! Далее в этом состоянии
               обращайтесь к вложенному объекту. Не всегда нужно вешать псевдокласс на тот объект, с которым должно
               что-то происходить. Псевдокласс <span class="span">hover</span> можно вешать на любой объект-родитель.
            </p>
            <p>Здесь у нас ссылка, которая становится видимой только при наведении на неё:</p>
         </div>
         <div class="block_2">
            <a href="" class="link_3">Я ссылка</a>
         </div>
         <div>
            <h4>Псевдокласс visited</h4>
            <p>Псевдокласс <span class="span">visited</span> срабатывает для посещённых ссылок.</p>
         </div>
         <div class="box">
            <p>Здесь у нас ссылка после посещения становится из исходного цвета того цвета, который мы задали.
               Исходным цветом был цвет orangered, конечным цветом стал цвет white:</p>
            <div class="block_3">
               <a href="" class="link_4">Я ссылка</a>
            </div>
            <p>Важное замечание!</p>
            <p>Из-за причин приватности, браузеры строго ограничивают стили, которые мы можем применить к элементу,
               используя этот псевдокласс <span class="span">visited</span>. Только color, background-color,
               border-color, border-bottom-color,
               border-left-color, border-right-color, border-top-color, outline-color, column-rule-color, fill и
               stroke. Заметим также, что альфа-канал будет игнорироваться: будет использоваться альфа-канал,
               используемый для непосещённых ссылок вместо него (но если прозрачность - 0, то в этом случае
               игнорируется весь цвет, и один из используемых стилей для непосещённых ссылок).</p>
         </div>
         <div class="box">
            <h4>Псевдокласс active</h4>
            <p>Этот псевдокласс призван повысить <span class="span">usability</span>. Он срабатывает, когда мы
               непосредственно кликнули на
               объект. Она активируется изменением цвета (<span class="span">active</span>) только в момент
               непосредственного зажатия её
               курсором мыши.</p>
            <div class="block_4">
               <a href="" class="link_5">Я ссылка</a>
            </div>
         </div>
         <div class="box">
            <p>А здесь у нас получилась кнопка с эффектом нажатия в момент клика. Для этого эффекта псевдокласс
               <span class="span">active</span> очень удобно использовать.
            </p>
            <div class="block_5">
               <a href="" class="link_6">Я типа кнопка</a>
            </div>
         </div>
         <div class="box">
            <h4>Псевдокласс focus</h4>
            <p>Срабатывает при получении элементом фокуса. Часто применяется к элементам форм, например к инпутам.
               Здесь, когда мы нажимаем на ссылку - ссылка обрамляется рамкой, как бы становится в фокусе. А сам
               текст ссылки при нажатии тоже меняют цвет.</p>
            <p>Играет роль порядок расположения псевдокласса. И если мы например, поставим этот псевдокласс перед
               другим, то идущий за этим может перебить действия.</p>
            <div class="block_6">
               <a href="" class="link_7">Я ссылка</a>
            </div>
         </div>

         <h4>Псевдокласс target</h4>
         <p>Псевдокласс <span class="span">target</span> срабатывает, когда элемент является объектом, на который
            ссылаются. Мы его в
            основном использовать не будем, потому что мы будем интерактив реализовывать в основном с помощью <span
               class="span_4">JS</span>.
         </p>
         <div class="block_7">
            <a href="#window" class="link_8">Я ссылка</a>
         </div>
         <div id="window" class="window">
            Изначально объект со значением window нам не виден, т.к. стоит значение .window {display:none} но при
            клике на ссылку объект будет показан (состояние .window:target {display: block} Минус этой штуки состоит
            в том, что мы будем прокручиваться, где бы мы ни находились. Скролл прокрутит к этому объекту, а это не
            всегда надо.)
         </div>
         <div class="block_8">
            <h3>Псевдоклассы положения в коде</h3>
            <div class="box">
               <p>Псевдоклассы положения в коде подразумевают, что мы можем из css без каких-то дополнительных вещей
                  html обращаться к тому или иному объекту, используя его положение (порядок вывода) в коде.</p>
            </div>
            <h4>Псевдокласс first-child</h4>
            <div class="box">
               <p>Псевдокласс <span class="span">first-child</span> обращается к первому элементу внутри родителя.
                  Синтаксис записи псевдоклассов положения в коде точно такой же, как и синтаксис псевдоклассов
                  состояния. Если подробнее разобраться, то псевдоклассы положения в коде это тоже псевдоклассы
                  состояния. В данном случае <span class="span">first-child</span> это псевдокласс, когда объект в
                  состоянии "первого внутри
                  родителя".</p>
               <p>У нас есть три параграфа внутри родителя, и с помощью псевдокласса <span
                     class="span">first-child</span>
                  мы можем обратиться
                  к первому из них.</p>
            </div>
            <div class="text">
               <p>
                  1. Первый параграф. В данном случае с помощью <span class="span">first-child</span> мы обратились к
                  первому параграфу. Если
                  мы поменяем местами первый параграф с каким-нибудь другим, то тот, который будет стоять вначале,
                  окрасится в зелёный цвет. Но если мы перед первым параграфом поставим какой-нибудь тэг, даже
                  пустой, то этот псевдокласс будет относиться уже не к первому параграфу, а к первому объекту
                  внутри родителя. Синтаксис - <span class="span_5">.text p:first-child {color: dark-green}</span>
               </p>
               <p>
                  Lorem ipsum dolor sit amet consectetur adipisicing elit. Praesentium illum alias omnis, animi
                  placeat excepturi? Itaque quas odio voluptatem architecto, tenetur neque sit modi? Ipsum sequi
                  saepe cumque deserunt dignissimos.
               </p>
               <p>
                  Lorem ipsum dolor sit amet consectetur adipisicing elit. Praesentium illum alias omnis, animi
                  placeat excepturi? Itaque quas odio voluptatem architecto, tenetur neque sit modi? Ipsum sequi
                  saepe cumque deserunt dignissimos.
               </p>
            </div>
            <h4>Псевдокласс first-of-type</h4>
            <div class="box">
               <div class="text">
                  <span></span>
                  <p>При этом псевдоклассе наш параграф окрасится независимо от того, если ли перед первым параграфом
                     какой-нибудь еще объект. <span class="span">first-of-type</span> обращается не к первому
                     объекту, а именно к первому тэгу.
                     В данный момент у нас перед параграфами стоит объект <span class="span">span</span>, но
                     псевдокласс обращается
                     именно к тэгу <span class="span">p</span>., либо к первому объекту, к которому он применён.
                     Синтаксис - <span class="span_5">.text p:first-of-type {color: darkviolet}</span>
                  </p>
                  <p>Какой из этих псевдоклассов использовать, зависит от той задачи, которую нам надо решить. Если
                     мы хотим, чтобы первый объект внутри родителя был красным, но если перед ним возникает что-то
                     еще, то он красным не будет, то мы используем <span class="span">first-child</span>.
                  </p>
                  <p>Если же нам нужно, чтобы всегда первый параграф внутри родителя всегда был красным, то мы
                     используем <span class="span">first-of-type</span>.
                  </p>
                  <p>Если нам надо, чтобы абсолютно любой объект, если стоит первым, как-то выделялся, то нам для
                     этого достаточно сделать вот такую запись - <span class="span_5">.text *:first-child {}</span>
                     Мы знаем, что <span class="span">*</span> (звёздочка) -
                     это такой селектор, который обращается абсолютно ко всем объектам, и соответственно при этой
                     записи абсолютно любой объект или тэг, который стоит первым, будет со значениями, которые мы
                     указали в этой записи.</p>
               </div>
            </div>
            <div class="box">
               <h4>Псевдоклас last-child</h4>
               <p>Псевдокласс <span class="span_3">last-child</span> работает также, как и псевдокласс <span
                     class="span_3">first-child</span>, только он срабатывает не на первый объект, а на последний.
               </p>
               <h4>Псевдокласс last-of-type</h4>
               <p>А псевдокласс <span class="span_3">last-of-type</span> работает также, как и псевдокласс <span
                     class="span_3">first-of-type</span>, только тоже срабатывает не в начале, а в конце, для
                  последнего объекта.</p>
               <p>Если например, нам нужно у последних объектов убрать нижние внешние отступы, то мы можем
                  воспользоваться вот такой записью - <span class="span_5">.text *:last-child {margin-bottom:
                     0;}</span></p>
               <h4>Псевдокласс nth-child</h4>
               <p>С помощью псевдокласса <span class="span_3">nth-child</span> мы можем обратиться не только к
                  первому и последнему объекту или
                  типу, а к конкретному. Например, ко второму. Для этого существует псевдокласс <span
                     class="span_3">nth-child</span>, и
                  синтаксис тут немного другой, потому что добавляются круглые скобки - <span class="span_5">.text
                     p:nth-child() {} </span>и в
                  этих круглых скобках мы собственно, можем писать любой порядковый номер, например <span
                     class="span_3">2</span>, и теперь любой
                  объект <span class="span_3">p</span> в данном случае, который будет на втором месте, он будет
                  красным. Соответственно при
                  добавлении каких-либо объектов это всё дело будет смещаться. </p>
            </div>
            <div class="box">
               <div class="text">
                  <p>Вообще псевдокласс <span class="span_3">nth-child</span> не очень
                     актуален, потому что при изменении контента всё это дело смещается, но довольно неплохо это
                     работает с другими настройками, например, настройками очерёдности. Например, с настройкой <span
                        class="span_5">.text p:nth-child(odd) {}</span> При указании вместо цифры в круглых скобочках
                     настройки <span class="span_3">odd</span> у нас будет
                     выделяться чередуясь, каждый нечётный объект, а при настройке <span class="span_5">.text
                        p:nth-child(even) {}</span> -
                     каждый чётный.</p>
                  <p>Вообще в круглых скобках можно указывать и более сложные комбинации, например - <span
                        class="span_5">.text p:nth-child(3n + 1) {}</span> Но вообще это знания справочные, и нужны
                     они крайне редко.</p>
                  <p>Немного про отступы. Если мы, например, захотим задать отступ у всех объектов, кроме первого, то
                     мы сделаем такую запись - <span class="span_5">.text: p:not(:last-child) {margin: 0px 0px 20px
                        0px}</span> Это можно
                     перевести как "Все, кроме..."</p>
                  <p>Мы можем вешать несколько псевдоклассов на объект. К примеру - <span class="span_5">.text
                        p:nth-child(2):hover {color: green;}</span> Порядок записи - сначала мы находим параграф,
                     который находится на втором месте
                     в коде, а потом мы вешаем на него прослушку <span class="span_3">hover</span>, т.е. нашли
                     объект, обратились к нему,
                     повесили <span class="span_3">hover</span>.</p>
               </div>
            </div>
            <h2>Псевдоэлементы</h2>
            <div class="box">
               <p>Псевдоэлементами обычно задают и меняют область, которая изначально отсутствовала в исходном файле.
                  Проще
                  говоря, псевдоэлементы задают новые области страницы, которых не было в HTML-разметке. Синтаксис
                  записи псевдоэлементов и псевдоклассов одинаков, единственное, что псевдоклассы записываются через
                  одно двоеточие, а псевдоклассы принято записывать через два двоеточия - <span
                     class="span_5">.content::first-line {color: blue;}</span></p>
               <h4>Псевдоэлемент first-line</h4>
               <p>Псевдоэлемент <span class="span_3">first-line</span> отвечает за первую строку ТЕКСТА. </p>
               <div class="content">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dicta natus, nostrum
                  iste, dolores cupiditate
                  delectus tempore explicabo molestiae adipisci quasi culpa numquam atque eum. Magni ex aut possimus
                  rem
                  alias.</div>
            </div>
            <h4>Псевдоэлемент first-letter</h4>
            <p>Псевдоэлемент <span class="span_3">first-letter</span> обращается к первой букве текста.</p>
            <div class="content_2">
               <p>Например, если мы зададим контенту параметр - <span class="span_5">.content
                     {text-indsent:30px;}</span> и псевдокласс ему же - <span class="span_5">.content::first-letter
                     {color: red; font-size: 60px;}</span>, то у нас будут начальные буквы практически как в книге:
               </p>
               <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Ratione vitae tempora, modi provident
                  neque perferendis, dolorum qui repellendus reiciendis illo porro quia illum necessitatibus facere
                  accusamus voluptatum sit. Veritatis, perferendis!</p>
               <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Dolor quod, esse commodi ipsum quis hic,
                  error sed explicabo voluptates quisquam aperiam nostrum rem adipisci praesentium ea tempore.
                  Labore, laborum asperiores!</p>
            </div>
            <h4>Псевдоэлементы before и after</h4>
            <p></p>
            <p>1. <span class="span_3">before</span> и <span class="span_3">after</span> - это строчные объекты!!!
            </p>
            <p>2. Они не работают без специального свойства <span class="span_3">content</span>!!! Потому что <span
                  class="span_3">before</span> и <span class="span_3">after</span> можно описать как сосуды. Это два
               сосуда, которые у нас могут появиться перед и после строки внутри одного объекта, свойства, параметра,
               но если мы не зададим ему свойство <span class="span_3">content</span>, они попросту не появятся.</p>
            <div class="box">
               <p class="content_3">Внутри этого параграфа мы выделим любую область строки, и псевдоэлементами <span
                     class="span_3">before</span> и <span class="span_3">after</span> можем обрамить это в то, что
                  нам нужно.</p>
            </div>
            <h1 class="title">Text</h1>
            <div class="box">
               <p>Если мы сделаем объект <span class="span_5">Text display: inline-block;</span> то можем длину линии
                  выставлять в процентах, например, если мы выставим длину в 50%, то линия всегда будет занимать
                  ровно половину текста.</p>
            </div>
            <h4>Пункты списка</h4>
            <div class="box">
               <p>Здесь мы задали отступы каждому пункту списка:</p>
            </div>
            <div class="box">
               <ul class="list">
                  <li>Здесь в пунктах списка с помощью <span class="span_5">.list li::before</span> мы сделали
                     круглый объект перед каждым пунктом списка.</li>
                  <li>Но если текст будет длинным, у нас текст в первой строке будет стоять строго по указанным
                     отступам, а снизу уже будет в той области, где стоят красные круглые объекты. Это будет зачастую
                     не очень красиво.</li>
                  <li>Решить проблему с заезжанием текста на область, где стоит красный круглый объект снизу, мы
                     сможем, если сделаем для каждого элемента слева (красного круглого объекта и текста) отступ в
                     20px, то у текстового элемента <span class="span_5">.list li {padding: 0px 0px 0px 20px;}</span>
                     а у красных круглых объектов <span class="span_5">.list li::before {margin: 7px 10px 0px
                        -20px;}</span></li>
                  <li>Получается, что мы сделали для каждого элемента списка отступ слева в 20px, а потом на эти 20px
                     мы вернули псевдоэлемент <span class="span_3">before</span>. Без этого возврата у нас просто был
                     бы отступ слева в 30px и текст с новой строки начинался бы уже не в месте, где он начинался
                     после красного круглого элемента.</li>
                  <li>А потом мы совмещаем псевдокласс и псевдоэлемент, и с помощью прослушки <span
                        class="span_3">hover</span> изменяем цвет красному круглому объекту при наведении на пункт
                     списка <span class="span_5">.list li:hover::before {background-color: darkblue;}</span></li>
                  <li>То есть, еще раз для закрепления! Сначала мы обращаемся к объекту .list <span
                        class="span_6">li</span> в определенном "состоянии души" <span class="span_6">:hover</span> а
                     потом обращаемся к псевдоэлементу <span class="span_6">::before</span> и меняем что-то у этого
                     псевдоэлемента.</li>
                  <li>То есть, по порядку, сначала идет <span class="span_5">.list li {}</span> потом <span
                        class="span_5">.list li::before {}</span> а потом <span class="span_5">.list li:hover::before
                        {}</span></li>
                  <li>Таким же образом мы можем добавить еще один псевдоэлемент справа after, если нам это нужно.
                  </li>
               </ul>
            </div>
            <div class="box">
               <h4>Нумерованный список</h4>
               <ol class="num-list">
                  <li>Мы сделали отступы у всех пунктов списка, кроме последнего этой записью <span
                        class="span_5">.num-list li:not(:nth-last-child) {margin: 0pxs 0px 20px 0px;}</span></li>
                  <li>У последнего пункта отступа не будет. Мы сделали это вот этой записью <span class="span_5">.list
                        {margin: 0px 0px 30px 0px;}</span></li>
                  <li>Вообще список <span class="span_3">ol</span> - нумерованный, но после обнуления мы не видим
                     никаких цифр. Как же нам поступить в этом случае?</li>
                  <li>Для реализации подобной задачи существует ряд свойств, которые используются только тут. Сначала
                     для самого списка мы пишем такую штуку <span class="span_5">.num-list {counter-reset:
                        item;}</span> она позволяет нам сбросить счётчик, то есть счёт идёт только внутри этого
                     списка. Это нужно для того, чтобы если у нас будет еще один такой же список, чтобы отчёт там не
                     продолжался, а начинался с нуля.</li>
                  <li>После обнуления мы что делаем? Мы, собственно, рисуем псевдоэлементы для наших пунктов списка.
                     И далее мы можем его стилизовать, чего мы не могли сделать со стандартным списком, именно
                     поэтому мы его и обнуляем.</li>
                  <li>Через запятую мы можем также обратиться сразу к двум псевдоэлементам, и задавать для них одно
                     значение <span class="span_5">.num-list li::before, .num-list li::after {}</span></li>
               </ol>
            </div>
         </div>
      </header>
   </main>
</body>

</html>